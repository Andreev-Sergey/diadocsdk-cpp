// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/AcceptanceCertificateInfo.proto

#ifndef PROTOBUF_Invoicing_2fAcceptanceCertificateInfo_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fAcceptanceCertificateInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Invoicing/Signer.pb.h"
#include "Invoicing/Official.pb.h"
#include "Invoicing/OrganizationInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
void protobuf_AssignDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
void protobuf_ShutdownFile_Invoicing_2fAcceptanceCertificateInfo_2eproto();

class AcceptanceCertificateSellerTitleInfo;
class AcceptanceCertificateBuyerTitleInfo;
class AcceptanceCertificateSignatureInfo;
class WorkDescription;
class WorkItem;

// ===================================================================

class AcceptanceCertificateSellerTitleInfo : public ::google::protobuf::Message {
 public:
  AcceptanceCertificateSellerTitleInfo();
  virtual ~AcceptanceCertificateSellerTitleInfo();
  
  AcceptanceCertificateSellerTitleInfo(const AcceptanceCertificateSellerTitleInfo& from);
  
  inline AcceptanceCertificateSellerTitleInfo& operator=(const AcceptanceCertificateSellerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptanceCertificateSellerTitleInfo& default_instance();
  
  void Swap(AcceptanceCertificateSellerTitleInfo* other);
  
  // implements Message ----------------------------------------------
  
  AcceptanceCertificateSellerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcceptanceCertificateSellerTitleInfo& from);
  void MergeFrom(const AcceptanceCertificateSellerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Seller = 1;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& seller() const;
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* mutable_seller();
  inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* release_seller();
  
  // required .Diadoc.Api.Proto.Invoicing.DocflowParticipant Buyer = 2;
  inline bool has_buyer() const;
  inline void clear_buyer();
  static const int kBuyerFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::DocflowParticipant& buyer() const;
  inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* mutable_buyer();
  inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* release_buyer();
  
  // required string DocumentDate = 3;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 3;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  
  // optional string DocumentNumber = 4;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 4;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  
  // required string DocumentTitle = 5;
  inline bool has_documenttitle() const;
  inline void clear_documenttitle();
  static const int kDocumentTitleFieldNumber = 5;
  inline const ::std::string& documenttitle() const;
  inline void set_documenttitle(const ::std::string& value);
  inline void set_documenttitle(const char* value);
  inline void set_documenttitle(const char* value, size_t size);
  inline ::std::string* mutable_documenttitle();
  inline ::std::string* release_documenttitle();
  
  // repeated .Diadoc.Api.Proto.Invoicing.WorkDescription Works = 6;
  inline int works_size() const;
  inline void clear_works();
  static const int kWorksFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::WorkDescription& works(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::WorkDescription* mutable_works(int index);
  inline ::Diadoc::Api::Proto::Invoicing::WorkDescription* add_works();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkDescription >&
      works() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkDescription >*
      mutable_works();
  
  // required .Diadoc.Api.Proto.Invoicing.AcceptanceCertificateSignatureInfo Signature = 7;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo& signature() const;
  inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* mutable_signature();
  inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* release_signature();
  
  // required .Diadoc.Api.Proto.Invoicing.Signer Signer = 8;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Invoicing::Signer& signer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signer* mutable_signer();
  inline ::Diadoc::Api::Proto::Invoicing::Signer* release_signer();
  
  // optional string AdditionalInfo = 9;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 9;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.AcceptanceCertificateSellerTitleInfo)
 private:
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_buyer();
  inline void clear_has_buyer();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_documenttitle();
  inline void clear_has_documenttitle();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_signer();
  inline void clear_has_signer();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* seller_;
  ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* buyer_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* documenttitle_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkDescription > works_;
  ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* signature_;
  ::Diadoc::Api::Proto::Invoicing::Signer* signer_;
  ::std::string* additionalinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AcceptanceCertificateSellerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class AcceptanceCertificateBuyerTitleInfo : public ::google::protobuf::Message {
 public:
  AcceptanceCertificateBuyerTitleInfo();
  virtual ~AcceptanceCertificateBuyerTitleInfo();
  
  AcceptanceCertificateBuyerTitleInfo(const AcceptanceCertificateBuyerTitleInfo& from);
  
  inline AcceptanceCertificateBuyerTitleInfo& operator=(const AcceptanceCertificateBuyerTitleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptanceCertificateBuyerTitleInfo& default_instance();
  
  void Swap(AcceptanceCertificateBuyerTitleInfo* other);
  
  // implements Message ----------------------------------------------
  
  AcceptanceCertificateBuyerTitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcceptanceCertificateBuyerTitleInfo& from);
  void MergeFrom(const AcceptanceCertificateBuyerTitleInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Complaints = 1;
  inline bool has_complaints() const;
  inline void clear_complaints();
  static const int kComplaintsFieldNumber = 1;
  inline const ::std::string& complaints() const;
  inline void set_complaints(const ::std::string& value);
  inline void set_complaints(const char* value);
  inline void set_complaints(const char* value, size_t size);
  inline ::std::string* mutable_complaints();
  inline ::std::string* release_complaints();
  
  // required .Diadoc.Api.Proto.Invoicing.AcceptanceCertificateSignatureInfo Signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo& signature() const;
  inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* mutable_signature();
  inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* release_signature();
  
  // required .Diadoc.Api.Proto.Invoicing.Signer Signer = 3;
  inline bool has_signer() const;
  inline void clear_signer();
  static const int kSignerFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::Signer& signer() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signer* mutable_signer();
  inline ::Diadoc::Api::Proto::Invoicing::Signer* release_signer();
  
  // optional string AdditionalInfo = 4;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 4;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.AcceptanceCertificateBuyerTitleInfo)
 private:
  inline void set_has_complaints();
  inline void clear_has_complaints();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_signer();
  inline void clear_has_signer();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* complaints_;
  ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* signature_;
  ::Diadoc::Api::Proto::Invoicing::Signer* signer_;
  ::std::string* additionalinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AcceptanceCertificateBuyerTitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class AcceptanceCertificateSignatureInfo : public ::google::protobuf::Message {
 public:
  AcceptanceCertificateSignatureInfo();
  virtual ~AcceptanceCertificateSignatureInfo();
  
  AcceptanceCertificateSignatureInfo(const AcceptanceCertificateSignatureInfo& from);
  
  inline AcceptanceCertificateSignatureInfo& operator=(const AcceptanceCertificateSignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptanceCertificateSignatureInfo& default_instance();
  
  void Swap(AcceptanceCertificateSignatureInfo* other);
  
  // implements Message ----------------------------------------------
  
  AcceptanceCertificateSignatureInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcceptanceCertificateSignatureInfo& from);
  void MergeFrom(const AcceptanceCertificateSignatureInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string SignatureDate = 1;
  inline bool has_signaturedate() const;
  inline void clear_signaturedate();
  static const int kSignatureDateFieldNumber = 1;
  inline const ::std::string& signaturedate() const;
  inline void set_signaturedate(const ::std::string& value);
  inline void set_signaturedate(const char* value);
  inline void set_signaturedate(const char* value, size_t size);
  inline ::std::string* mutable_signaturedate();
  inline ::std::string* release_signaturedate();
  
  // optional .Diadoc.Api.Proto.Invoicing.Official Official = 2;
  inline bool has_official() const;
  inline void clear_official();
  static const int kOfficialFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Invoicing::Official& official() const;
  inline ::Diadoc::Api::Proto::Invoicing::Official* mutable_official();
  inline ::Diadoc::Api::Proto::Invoicing::Official* release_official();
  
  // optional .Diadoc.Api.Proto.Invoicing.Attorney Attorney = 3;
  inline bool has_attorney() const;
  inline void clear_attorney();
  static const int kAttorneyFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Invoicing::Attorney& attorney() const;
  inline ::Diadoc::Api::Proto::Invoicing::Attorney* mutable_attorney();
  inline ::Diadoc::Api::Proto::Invoicing::Attorney* release_attorney();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.AcceptanceCertificateSignatureInfo)
 private:
  inline void set_has_signaturedate();
  inline void clear_has_signaturedate();
  inline void set_has_official();
  inline void clear_has_official();
  inline void set_has_attorney();
  inline void clear_has_attorney();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* signaturedate_;
  ::Diadoc::Api::Proto::Invoicing::Official* official_;
  ::Diadoc::Api::Proto::Invoicing::Attorney* attorney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  
  void InitAsDefaultInstance();
  static AcceptanceCertificateSignatureInfo* default_instance_;
};
// -------------------------------------------------------------------

class WorkDescription : public ::google::protobuf::Message {
 public:
  WorkDescription();
  virtual ~WorkDescription();
  
  WorkDescription(const WorkDescription& from);
  
  inline WorkDescription& operator=(const WorkDescription& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkDescription& default_instance();
  
  void Swap(WorkDescription* other);
  
  // implements Message ----------------------------------------------
  
  WorkDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkDescription& from);
  void MergeFrom(const WorkDescription& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string StartingDate = 1;
  inline bool has_startingdate() const;
  inline void clear_startingdate();
  static const int kStartingDateFieldNumber = 1;
  inline const ::std::string& startingdate() const;
  inline void set_startingdate(const ::std::string& value);
  inline void set_startingdate(const char* value);
  inline void set_startingdate(const char* value, size_t size);
  inline ::std::string* mutable_startingdate();
  inline ::std::string* release_startingdate();
  
  // optional string CompletionDate = 2;
  inline bool has_completiondate() const;
  inline void clear_completiondate();
  static const int kCompletionDateFieldNumber = 2;
  inline const ::std::string& completiondate() const;
  inline void set_completiondate(const ::std::string& value);
  inline void set_completiondate(const char* value);
  inline void set_completiondate(const char* value, size_t size);
  inline ::std::string* mutable_completiondate();
  inline ::std::string* release_completiondate();
  
  // optional string TotalWithVatExcluded = 3;
  inline bool has_totalwithvatexcluded() const;
  inline void clear_totalwithvatexcluded();
  static const int kTotalWithVatExcludedFieldNumber = 3;
  inline const ::std::string& totalwithvatexcluded() const;
  inline void set_totalwithvatexcluded(const ::std::string& value);
  inline void set_totalwithvatexcluded(const char* value);
  inline void set_totalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_totalwithvatexcluded();
  inline ::std::string* release_totalwithvatexcluded();
  
  // optional string Vat = 4;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 4;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  
  // required string Total = 5;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 5;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  
  // repeated .Diadoc.Api.Proto.Invoicing.WorkItem Items = 6;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Invoicing::WorkItem& items(int index) const;
  inline ::Diadoc::Api::Proto::Invoicing::WorkItem* mutable_items(int index);
  inline ::Diadoc::Api::Proto::Invoicing::WorkItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkItem >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.WorkDescription)
 private:
  inline void set_has_startingdate();
  inline void clear_has_startingdate();
  inline void set_has_completiondate();
  inline void clear_has_completiondate();
  inline void set_has_totalwithvatexcluded();
  inline void clear_has_totalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_total();
  inline void clear_has_total();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* startingdate_;
  ::std::string* completiondate_;
  ::std::string* totalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* total_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkItem > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  
  void InitAsDefaultInstance();
  static WorkDescription* default_instance_;
};
// -------------------------------------------------------------------

class WorkItem : public ::google::protobuf::Message {
 public:
  WorkItem();
  virtual ~WorkItem();
  
  WorkItem(const WorkItem& from);
  
  inline WorkItem& operator=(const WorkItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkItem& default_instance();
  
  void Swap(WorkItem* other);
  
  // implements Message ----------------------------------------------
  
  WorkItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkItem& from);
  void MergeFrom(const WorkItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string Description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string UnitCode = 3;
  inline bool has_unitcode() const;
  inline void clear_unitcode();
  static const int kUnitCodeFieldNumber = 3;
  inline const ::std::string& unitcode() const;
  inline void set_unitcode(const ::std::string& value);
  inline void set_unitcode(const char* value);
  inline void set_unitcode(const char* value, size_t size);
  inline ::std::string* mutable_unitcode();
  inline ::std::string* release_unitcode();
  
  // optional string UnitName = 4;
  inline bool has_unitname() const;
  inline void clear_unitname();
  static const int kUnitNameFieldNumber = 4;
  inline const ::std::string& unitname() const;
  inline void set_unitname(const ::std::string& value);
  inline void set_unitname(const char* value);
  inline void set_unitname(const char* value, size_t size);
  inline ::std::string* mutable_unitname();
  inline ::std::string* release_unitname();
  
  // optional string Price = 5;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 5;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  
  // optional string Quantity = 6;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  inline const ::std::string& quantity() const;
  inline void set_quantity(const ::std::string& value);
  inline void set_quantity(const char* value);
  inline void set_quantity(const char* value, size_t size);
  inline ::std::string* mutable_quantity();
  inline ::std::string* release_quantity();
  
  // optional string SubtotalWithVatExcluded = 7;
  inline bool has_subtotalwithvatexcluded() const;
  inline void clear_subtotalwithvatexcluded();
  static const int kSubtotalWithVatExcludedFieldNumber = 7;
  inline const ::std::string& subtotalwithvatexcluded() const;
  inline void set_subtotalwithvatexcluded(const ::std::string& value);
  inline void set_subtotalwithvatexcluded(const char* value);
  inline void set_subtotalwithvatexcluded(const char* value, size_t size);
  inline ::std::string* mutable_subtotalwithvatexcluded();
  inline ::std::string* release_subtotalwithvatexcluded();
  
  // optional string Vat = 8;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 8;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  
  // optional string Subtotal = 9;
  inline bool has_subtotal() const;
  inline void clear_subtotal();
  static const int kSubtotalFieldNumber = 9;
  inline const ::std::string& subtotal() const;
  inline void set_subtotal(const ::std::string& value);
  inline void set_subtotal(const char* value);
  inline void set_subtotal(const char* value, size_t size);
  inline ::std::string* mutable_subtotal();
  inline ::std::string* release_subtotal();
  
  // optional string AdditionalInfo = 10;
  inline bool has_additionalinfo() const;
  inline void clear_additionalinfo();
  static const int kAdditionalInfoFieldNumber = 10;
  inline const ::std::string& additionalinfo() const;
  inline void set_additionalinfo(const ::std::string& value);
  inline void set_additionalinfo(const char* value);
  inline void set_additionalinfo(const char* value, size_t size);
  inline ::std::string* mutable_additionalinfo();
  inline ::std::string* release_additionalinfo();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.WorkItem)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_unitcode();
  inline void clear_has_unitcode();
  inline void set_has_unitname();
  inline void clear_has_unitname();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_subtotalwithvatexcluded();
  inline void clear_has_subtotalwithvatexcluded();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_subtotal();
  inline void clear_has_subtotal();
  inline void set_has_additionalinfo();
  inline void clear_has_additionalinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* description_;
  ::std::string* unitcode_;
  ::std::string* unitname_;
  ::std::string* price_;
  ::std::string* quantity_;
  ::std::string* subtotalwithvatexcluded_;
  ::std::string* vat_;
  ::std::string* subtotal_;
  ::std::string* additionalinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fAcceptanceCertificateInfo_2eproto();
  
  void InitAsDefaultInstance();
  static WorkItem* default_instance_;
};
// ===================================================================


// ===================================================================

// AcceptanceCertificateSellerTitleInfo

// required .Diadoc.Api.Proto.Invoicing.DiadocOrganizationInfo Seller = 1;
inline bool AcceptanceCertificateSellerTitleInfo::has_seller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_seller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_seller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_seller() {
  if (seller_ != NULL) seller_->::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo::Clear();
  clear_has_seller();
}
inline const ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo& AcceptanceCertificateSellerTitleInfo::seller() const {
  return seller_ != NULL ? *seller_ : *default_instance_->seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* AcceptanceCertificateSellerTitleInfo::mutable_seller() {
  set_has_seller();
  if (seller_ == NULL) seller_ = new ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo;
  return seller_;
}
inline ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* AcceptanceCertificateSellerTitleInfo::release_seller() {
  clear_has_seller();
  ::Diadoc::Api::Proto::Invoicing::DiadocOrganizationInfo* temp = seller_;
  seller_ = NULL;
  return temp;
}

// required .Diadoc.Api.Proto.Invoicing.DocflowParticipant Buyer = 2;
inline bool AcceptanceCertificateSellerTitleInfo::has_buyer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_buyer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_buyer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_buyer() {
  if (buyer_ != NULL) buyer_->::Diadoc::Api::Proto::Invoicing::DocflowParticipant::Clear();
  clear_has_buyer();
}
inline const ::Diadoc::Api::Proto::Invoicing::DocflowParticipant& AcceptanceCertificateSellerTitleInfo::buyer() const {
  return buyer_ != NULL ? *buyer_ : *default_instance_->buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* AcceptanceCertificateSellerTitleInfo::mutable_buyer() {
  set_has_buyer();
  if (buyer_ == NULL) buyer_ = new ::Diadoc::Api::Proto::Invoicing::DocflowParticipant;
  return buyer_;
}
inline ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* AcceptanceCertificateSellerTitleInfo::release_buyer() {
  clear_has_buyer();
  ::Diadoc::Api::Proto::Invoicing::DocflowParticipant* temp = buyer_;
  buyer_ = NULL;
  return temp;
}

// required string DocumentDate = 3;
inline bool AcceptanceCertificateSellerTitleInfo::has_documentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_documentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& AcceptanceCertificateSellerTitleInfo::documentdate() const {
  return *documentdate_;
}
inline void AcceptanceCertificateSellerTitleInfo::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DocumentNumber = 4;
inline bool AcceptanceCertificateSellerTitleInfo::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& AcceptanceCertificateSellerTitleInfo::documentnumber() const {
  return *documentnumber_;
}
inline void AcceptanceCertificateSellerTitleInfo::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string DocumentTitle = 5;
inline bool AcceptanceCertificateSellerTitleInfo::has_documenttitle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_documenttitle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_documenttitle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_documenttitle() {
  if (documenttitle_ != &::google::protobuf::internal::kEmptyString) {
    documenttitle_->clear();
  }
  clear_has_documenttitle();
}
inline const ::std::string& AcceptanceCertificateSellerTitleInfo::documenttitle() const {
  return *documenttitle_;
}
inline void AcceptanceCertificateSellerTitleInfo::set_documenttitle(const ::std::string& value) {
  set_has_documenttitle();
  if (documenttitle_ == &::google::protobuf::internal::kEmptyString) {
    documenttitle_ = new ::std::string;
  }
  documenttitle_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_documenttitle(const char* value) {
  set_has_documenttitle();
  if (documenttitle_ == &::google::protobuf::internal::kEmptyString) {
    documenttitle_ = new ::std::string;
  }
  documenttitle_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_documenttitle(const char* value, size_t size) {
  set_has_documenttitle();
  if (documenttitle_ == &::google::protobuf::internal::kEmptyString) {
    documenttitle_ = new ::std::string;
  }
  documenttitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::mutable_documenttitle() {
  set_has_documenttitle();
  if (documenttitle_ == &::google::protobuf::internal::kEmptyString) {
    documenttitle_ = new ::std::string;
  }
  return documenttitle_;
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::release_documenttitle() {
  clear_has_documenttitle();
  if (documenttitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documenttitle_;
    documenttitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Diadoc.Api.Proto.Invoicing.WorkDescription Works = 6;
inline int AcceptanceCertificateSellerTitleInfo::works_size() const {
  return works_.size();
}
inline void AcceptanceCertificateSellerTitleInfo::clear_works() {
  works_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::WorkDescription& AcceptanceCertificateSellerTitleInfo::works(int index) const {
  return works_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::WorkDescription* AcceptanceCertificateSellerTitleInfo::mutable_works(int index) {
  return works_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::WorkDescription* AcceptanceCertificateSellerTitleInfo::add_works() {
  return works_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkDescription >&
AcceptanceCertificateSellerTitleInfo::works() const {
  return works_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkDescription >*
AcceptanceCertificateSellerTitleInfo::mutable_works() {
  return &works_;
}

// required .Diadoc.Api.Proto.Invoicing.AcceptanceCertificateSignatureInfo Signature = 7;
inline bool AcceptanceCertificateSellerTitleInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_signature() {
  if (signature_ != NULL) signature_->::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo::Clear();
  clear_has_signature();
}
inline const ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo& AcceptanceCertificateSellerTitleInfo::signature() const {
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* AcceptanceCertificateSellerTitleInfo::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo;
  return signature_;
}
inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* AcceptanceCertificateSellerTitleInfo::release_signature() {
  clear_has_signature();
  ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* temp = signature_;
  signature_ = NULL;
  return temp;
}

// required .Diadoc.Api.Proto.Invoicing.Signer Signer = 8;
inline bool AcceptanceCertificateSellerTitleInfo::has_signer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_signer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_signer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_signer() {
  if (signer_ != NULL) signer_->::Diadoc::Api::Proto::Invoicing::Signer::Clear();
  clear_has_signer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signer& AcceptanceCertificateSellerTitleInfo::signer() const {
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* AcceptanceCertificateSellerTitleInfo::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::Diadoc::Api::Proto::Invoicing::Signer;
  return signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* AcceptanceCertificateSellerTitleInfo::release_signer() {
  clear_has_signer();
  ::Diadoc::Api::Proto::Invoicing::Signer* temp = signer_;
  signer_ = NULL;
  return temp;
}

// optional string AdditionalInfo = 9;
inline bool AcceptanceCertificateSellerTitleInfo::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AcceptanceCertificateSellerTitleInfo::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AcceptanceCertificateSellerTitleInfo::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::kEmptyString) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& AcceptanceCertificateSellerTitleInfo::additionalinfo() const {
  return *additionalinfo_;
}
inline void AcceptanceCertificateSellerTitleInfo::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void AcceptanceCertificateSellerTitleInfo::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  return additionalinfo_;
}
inline ::std::string* AcceptanceCertificateSellerTitleInfo::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AcceptanceCertificateBuyerTitleInfo

// optional string Complaints = 1;
inline bool AcceptanceCertificateBuyerTitleInfo::has_complaints() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptanceCertificateBuyerTitleInfo::set_has_complaints() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_has_complaints() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_complaints() {
  if (complaints_ != &::google::protobuf::internal::kEmptyString) {
    complaints_->clear();
  }
  clear_has_complaints();
}
inline const ::std::string& AcceptanceCertificateBuyerTitleInfo::complaints() const {
  return *complaints_;
}
inline void AcceptanceCertificateBuyerTitleInfo::set_complaints(const ::std::string& value) {
  set_has_complaints();
  if (complaints_ == &::google::protobuf::internal::kEmptyString) {
    complaints_ = new ::std::string;
  }
  complaints_->assign(value);
}
inline void AcceptanceCertificateBuyerTitleInfo::set_complaints(const char* value) {
  set_has_complaints();
  if (complaints_ == &::google::protobuf::internal::kEmptyString) {
    complaints_ = new ::std::string;
  }
  complaints_->assign(value);
}
inline void AcceptanceCertificateBuyerTitleInfo::set_complaints(const char* value, size_t size) {
  set_has_complaints();
  if (complaints_ == &::google::protobuf::internal::kEmptyString) {
    complaints_ = new ::std::string;
  }
  complaints_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateBuyerTitleInfo::mutable_complaints() {
  set_has_complaints();
  if (complaints_ == &::google::protobuf::internal::kEmptyString) {
    complaints_ = new ::std::string;
  }
  return complaints_;
}
inline ::std::string* AcceptanceCertificateBuyerTitleInfo::release_complaints() {
  clear_has_complaints();
  if (complaints_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = complaints_;
    complaints_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Diadoc.Api.Proto.Invoicing.AcceptanceCertificateSignatureInfo Signature = 2;
inline bool AcceptanceCertificateBuyerTitleInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptanceCertificateBuyerTitleInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_signature() {
  if (signature_ != NULL) signature_->::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo::Clear();
  clear_has_signature();
}
inline const ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo& AcceptanceCertificateBuyerTitleInfo::signature() const {
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* AcceptanceCertificateBuyerTitleInfo::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo;
  return signature_;
}
inline ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* AcceptanceCertificateBuyerTitleInfo::release_signature() {
  clear_has_signature();
  ::Diadoc::Api::Proto::Invoicing::AcceptanceCertificateSignatureInfo* temp = signature_;
  signature_ = NULL;
  return temp;
}

// required .Diadoc.Api.Proto.Invoicing.Signer Signer = 3;
inline bool AcceptanceCertificateBuyerTitleInfo::has_signer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcceptanceCertificateBuyerTitleInfo::set_has_signer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_has_signer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_signer() {
  if (signer_ != NULL) signer_->::Diadoc::Api::Proto::Invoicing::Signer::Clear();
  clear_has_signer();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signer& AcceptanceCertificateBuyerTitleInfo::signer() const {
  return signer_ != NULL ? *signer_ : *default_instance_->signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* AcceptanceCertificateBuyerTitleInfo::mutable_signer() {
  set_has_signer();
  if (signer_ == NULL) signer_ = new ::Diadoc::Api::Proto::Invoicing::Signer;
  return signer_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signer* AcceptanceCertificateBuyerTitleInfo::release_signer() {
  clear_has_signer();
  ::Diadoc::Api::Proto::Invoicing::Signer* temp = signer_;
  signer_ = NULL;
  return temp;
}

// optional string AdditionalInfo = 4;
inline bool AcceptanceCertificateBuyerTitleInfo::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AcceptanceCertificateBuyerTitleInfo::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AcceptanceCertificateBuyerTitleInfo::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::kEmptyString) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& AcceptanceCertificateBuyerTitleInfo::additionalinfo() const {
  return *additionalinfo_;
}
inline void AcceptanceCertificateBuyerTitleInfo::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void AcceptanceCertificateBuyerTitleInfo::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void AcceptanceCertificateBuyerTitleInfo::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateBuyerTitleInfo::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  return additionalinfo_;
}
inline ::std::string* AcceptanceCertificateBuyerTitleInfo::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AcceptanceCertificateSignatureInfo

// optional string SignatureDate = 1;
inline bool AcceptanceCertificateSignatureInfo::has_signaturedate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptanceCertificateSignatureInfo::set_has_signaturedate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptanceCertificateSignatureInfo::clear_has_signaturedate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptanceCertificateSignatureInfo::clear_signaturedate() {
  if (signaturedate_ != &::google::protobuf::internal::kEmptyString) {
    signaturedate_->clear();
  }
  clear_has_signaturedate();
}
inline const ::std::string& AcceptanceCertificateSignatureInfo::signaturedate() const {
  return *signaturedate_;
}
inline void AcceptanceCertificateSignatureInfo::set_signaturedate(const ::std::string& value) {
  set_has_signaturedate();
  if (signaturedate_ == &::google::protobuf::internal::kEmptyString) {
    signaturedate_ = new ::std::string;
  }
  signaturedate_->assign(value);
}
inline void AcceptanceCertificateSignatureInfo::set_signaturedate(const char* value) {
  set_has_signaturedate();
  if (signaturedate_ == &::google::protobuf::internal::kEmptyString) {
    signaturedate_ = new ::std::string;
  }
  signaturedate_->assign(value);
}
inline void AcceptanceCertificateSignatureInfo::set_signaturedate(const char* value, size_t size) {
  set_has_signaturedate();
  if (signaturedate_ == &::google::protobuf::internal::kEmptyString) {
    signaturedate_ = new ::std::string;
  }
  signaturedate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AcceptanceCertificateSignatureInfo::mutable_signaturedate() {
  set_has_signaturedate();
  if (signaturedate_ == &::google::protobuf::internal::kEmptyString) {
    signaturedate_ = new ::std::string;
  }
  return signaturedate_;
}
inline ::std::string* AcceptanceCertificateSignatureInfo::release_signaturedate() {
  clear_has_signaturedate();
  if (signaturedate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signaturedate_;
    signaturedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Invoicing.Official Official = 2;
inline bool AcceptanceCertificateSignatureInfo::has_official() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptanceCertificateSignatureInfo::set_has_official() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptanceCertificateSignatureInfo::clear_has_official() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptanceCertificateSignatureInfo::clear_official() {
  if (official_ != NULL) official_->::Diadoc::Api::Proto::Invoicing::Official::Clear();
  clear_has_official();
}
inline const ::Diadoc::Api::Proto::Invoicing::Official& AcceptanceCertificateSignatureInfo::official() const {
  return official_ != NULL ? *official_ : *default_instance_->official_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* AcceptanceCertificateSignatureInfo::mutable_official() {
  set_has_official();
  if (official_ == NULL) official_ = new ::Diadoc::Api::Proto::Invoicing::Official;
  return official_;
}
inline ::Diadoc::Api::Proto::Invoicing::Official* AcceptanceCertificateSignatureInfo::release_official() {
  clear_has_official();
  ::Diadoc::Api::Proto::Invoicing::Official* temp = official_;
  official_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Invoicing.Attorney Attorney = 3;
inline bool AcceptanceCertificateSignatureInfo::has_attorney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcceptanceCertificateSignatureInfo::set_has_attorney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcceptanceCertificateSignatureInfo::clear_has_attorney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcceptanceCertificateSignatureInfo::clear_attorney() {
  if (attorney_ != NULL) attorney_->::Diadoc::Api::Proto::Invoicing::Attorney::Clear();
  clear_has_attorney();
}
inline const ::Diadoc::Api::Proto::Invoicing::Attorney& AcceptanceCertificateSignatureInfo::attorney() const {
  return attorney_ != NULL ? *attorney_ : *default_instance_->attorney_;
}
inline ::Diadoc::Api::Proto::Invoicing::Attorney* AcceptanceCertificateSignatureInfo::mutable_attorney() {
  set_has_attorney();
  if (attorney_ == NULL) attorney_ = new ::Diadoc::Api::Proto::Invoicing::Attorney;
  return attorney_;
}
inline ::Diadoc::Api::Proto::Invoicing::Attorney* AcceptanceCertificateSignatureInfo::release_attorney() {
  clear_has_attorney();
  ::Diadoc::Api::Proto::Invoicing::Attorney* temp = attorney_;
  attorney_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// WorkDescription

// optional string StartingDate = 1;
inline bool WorkDescription::has_startingdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkDescription::set_has_startingdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkDescription::clear_has_startingdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkDescription::clear_startingdate() {
  if (startingdate_ != &::google::protobuf::internal::kEmptyString) {
    startingdate_->clear();
  }
  clear_has_startingdate();
}
inline const ::std::string& WorkDescription::startingdate() const {
  return *startingdate_;
}
inline void WorkDescription::set_startingdate(const ::std::string& value) {
  set_has_startingdate();
  if (startingdate_ == &::google::protobuf::internal::kEmptyString) {
    startingdate_ = new ::std::string;
  }
  startingdate_->assign(value);
}
inline void WorkDescription::set_startingdate(const char* value) {
  set_has_startingdate();
  if (startingdate_ == &::google::protobuf::internal::kEmptyString) {
    startingdate_ = new ::std::string;
  }
  startingdate_->assign(value);
}
inline void WorkDescription::set_startingdate(const char* value, size_t size) {
  set_has_startingdate();
  if (startingdate_ == &::google::protobuf::internal::kEmptyString) {
    startingdate_ = new ::std::string;
  }
  startingdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkDescription::mutable_startingdate() {
  set_has_startingdate();
  if (startingdate_ == &::google::protobuf::internal::kEmptyString) {
    startingdate_ = new ::std::string;
  }
  return startingdate_;
}
inline ::std::string* WorkDescription::release_startingdate() {
  clear_has_startingdate();
  if (startingdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startingdate_;
    startingdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CompletionDate = 2;
inline bool WorkDescription::has_completiondate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkDescription::set_has_completiondate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkDescription::clear_has_completiondate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkDescription::clear_completiondate() {
  if (completiondate_ != &::google::protobuf::internal::kEmptyString) {
    completiondate_->clear();
  }
  clear_has_completiondate();
}
inline const ::std::string& WorkDescription::completiondate() const {
  return *completiondate_;
}
inline void WorkDescription::set_completiondate(const ::std::string& value) {
  set_has_completiondate();
  if (completiondate_ == &::google::protobuf::internal::kEmptyString) {
    completiondate_ = new ::std::string;
  }
  completiondate_->assign(value);
}
inline void WorkDescription::set_completiondate(const char* value) {
  set_has_completiondate();
  if (completiondate_ == &::google::protobuf::internal::kEmptyString) {
    completiondate_ = new ::std::string;
  }
  completiondate_->assign(value);
}
inline void WorkDescription::set_completiondate(const char* value, size_t size) {
  set_has_completiondate();
  if (completiondate_ == &::google::protobuf::internal::kEmptyString) {
    completiondate_ = new ::std::string;
  }
  completiondate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkDescription::mutable_completiondate() {
  set_has_completiondate();
  if (completiondate_ == &::google::protobuf::internal::kEmptyString) {
    completiondate_ = new ::std::string;
  }
  return completiondate_;
}
inline ::std::string* WorkDescription::release_completiondate() {
  clear_has_completiondate();
  if (completiondate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = completiondate_;
    completiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TotalWithVatExcluded = 3;
inline bool WorkDescription::has_totalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkDescription::set_has_totalwithvatexcluded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkDescription::clear_has_totalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkDescription::clear_totalwithvatexcluded() {
  if (totalwithvatexcluded_ != &::google::protobuf::internal::kEmptyString) {
    totalwithvatexcluded_->clear();
  }
  clear_has_totalwithvatexcluded();
}
inline const ::std::string& WorkDescription::totalwithvatexcluded() const {
  return *totalwithvatexcluded_;
}
inline void WorkDescription::set_totalwithvatexcluded(const ::std::string& value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
}
inline void WorkDescription::set_totalwithvatexcluded(const char* value) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(value);
}
inline void WorkDescription::set_totalwithvatexcluded(const char* value, size_t size) {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    totalwithvatexcluded_ = new ::std::string;
  }
  totalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkDescription::mutable_totalwithvatexcluded() {
  set_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    totalwithvatexcluded_ = new ::std::string;
  }
  return totalwithvatexcluded_;
}
inline ::std::string* WorkDescription::release_totalwithvatexcluded() {
  clear_has_totalwithvatexcluded();
  if (totalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totalwithvatexcluded_;
    totalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Vat = 4;
inline bool WorkDescription::has_vat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorkDescription::set_has_vat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorkDescription::clear_has_vat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorkDescription::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& WorkDescription::vat() const {
  return *vat_;
}
inline void WorkDescription::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void WorkDescription::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void WorkDescription::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkDescription::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* WorkDescription::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Total = 5;
inline bool WorkDescription::has_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorkDescription::set_has_total() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorkDescription::clear_has_total() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorkDescription::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& WorkDescription::total() const {
  return *total_;
}
inline void WorkDescription::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void WorkDescription::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void WorkDescription::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkDescription::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* WorkDescription::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Diadoc.Api.Proto.Invoicing.WorkItem Items = 6;
inline int WorkDescription::items_size() const {
  return items_.size();
}
inline void WorkDescription::clear_items() {
  items_.Clear();
}
inline const ::Diadoc::Api::Proto::Invoicing::WorkItem& WorkDescription::items(int index) const {
  return items_.Get(index);
}
inline ::Diadoc::Api::Proto::Invoicing::WorkItem* WorkDescription::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Invoicing::WorkItem* WorkDescription::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkItem >&
WorkDescription::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Invoicing::WorkItem >*
WorkDescription::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// WorkItem

// optional string Name = 1;
inline bool WorkItem::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkItem::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WorkItem::name() const {
  return *name_;
}
inline void WorkItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WorkItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WorkItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WorkItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Description = 2;
inline bool WorkItem::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkItem::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkItem::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkItem::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& WorkItem::description() const {
  return *description_;
}
inline void WorkItem::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void WorkItem::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void WorkItem::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* WorkItem::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UnitCode = 3;
inline bool WorkItem::has_unitcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkItem::set_has_unitcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkItem::clear_has_unitcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkItem::clear_unitcode() {
  if (unitcode_ != &::google::protobuf::internal::kEmptyString) {
    unitcode_->clear();
  }
  clear_has_unitcode();
}
inline const ::std::string& WorkItem::unitcode() const {
  return *unitcode_;
}
inline void WorkItem::set_unitcode(const ::std::string& value) {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::kEmptyString) {
    unitcode_ = new ::std::string;
  }
  unitcode_->assign(value);
}
inline void WorkItem::set_unitcode(const char* value) {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::kEmptyString) {
    unitcode_ = new ::std::string;
  }
  unitcode_->assign(value);
}
inline void WorkItem::set_unitcode(const char* value, size_t size) {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::kEmptyString) {
    unitcode_ = new ::std::string;
  }
  unitcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_unitcode() {
  set_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::kEmptyString) {
    unitcode_ = new ::std::string;
  }
  return unitcode_;
}
inline ::std::string* WorkItem::release_unitcode() {
  clear_has_unitcode();
  if (unitcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unitcode_;
    unitcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UnitName = 4;
inline bool WorkItem::has_unitname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorkItem::set_has_unitname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorkItem::clear_has_unitname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorkItem::clear_unitname() {
  if (unitname_ != &::google::protobuf::internal::kEmptyString) {
    unitname_->clear();
  }
  clear_has_unitname();
}
inline const ::std::string& WorkItem::unitname() const {
  return *unitname_;
}
inline void WorkItem::set_unitname(const ::std::string& value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::kEmptyString) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
}
inline void WorkItem::set_unitname(const char* value) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::kEmptyString) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(value);
}
inline void WorkItem::set_unitname(const char* value, size_t size) {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::kEmptyString) {
    unitname_ = new ::std::string;
  }
  unitname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_unitname() {
  set_has_unitname();
  if (unitname_ == &::google::protobuf::internal::kEmptyString) {
    unitname_ = new ::std::string;
  }
  return unitname_;
}
inline ::std::string* WorkItem::release_unitname() {
  clear_has_unitname();
  if (unitname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unitname_;
    unitname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Price = 5;
inline bool WorkItem::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorkItem::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorkItem::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorkItem::clear_price() {
  if (price_ != &::google::protobuf::internal::kEmptyString) {
    price_->clear();
  }
  clear_has_price();
}
inline const ::std::string& WorkItem::price() const {
  return *price_;
}
inline void WorkItem::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void WorkItem::set_price(const char* value) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void WorkItem::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_price() {
  set_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    price_ = new ::std::string;
  }
  return price_;
}
inline ::std::string* WorkItem::release_price() {
  clear_has_price();
  if (price_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Quantity = 6;
inline bool WorkItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WorkItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WorkItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WorkItem::clear_quantity() {
  if (quantity_ != &::google::protobuf::internal::kEmptyString) {
    quantity_->clear();
  }
  clear_has_quantity();
}
inline const ::std::string& WorkItem::quantity() const {
  return *quantity_;
}
inline void WorkItem::set_quantity(const ::std::string& value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
}
inline void WorkItem::set_quantity(const char* value) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(value);
}
inline void WorkItem::set_quantity(const char* value, size_t size) {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  quantity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_quantity() {
  set_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    quantity_ = new ::std::string;
  }
  return quantity_;
}
inline ::std::string* WorkItem::release_quantity() {
  clear_has_quantity();
  if (quantity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quantity_;
    quantity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SubtotalWithVatExcluded = 7;
inline bool WorkItem::has_subtotalwithvatexcluded() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WorkItem::set_has_subtotalwithvatexcluded() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WorkItem::clear_has_subtotalwithvatexcluded() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WorkItem::clear_subtotalwithvatexcluded() {
  if (subtotalwithvatexcluded_ != &::google::protobuf::internal::kEmptyString) {
    subtotalwithvatexcluded_->clear();
  }
  clear_has_subtotalwithvatexcluded();
}
inline const ::std::string& WorkItem::subtotalwithvatexcluded() const {
  return *subtotalwithvatexcluded_;
}
inline void WorkItem::set_subtotalwithvatexcluded(const ::std::string& value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
}
inline void WorkItem::set_subtotalwithvatexcluded(const char* value) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(value);
}
inline void WorkItem::set_subtotalwithvatexcluded(const char* value, size_t size) {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  subtotalwithvatexcluded_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_subtotalwithvatexcluded() {
  set_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    subtotalwithvatexcluded_ = new ::std::string;
  }
  return subtotalwithvatexcluded_;
}
inline ::std::string* WorkItem::release_subtotalwithvatexcluded() {
  clear_has_subtotalwithvatexcluded();
  if (subtotalwithvatexcluded_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtotalwithvatexcluded_;
    subtotalwithvatexcluded_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Vat = 8;
inline bool WorkItem::has_vat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WorkItem::set_has_vat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WorkItem::clear_has_vat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WorkItem::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& WorkItem::vat() const {
  return *vat_;
}
inline void WorkItem::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void WorkItem::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void WorkItem::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* WorkItem::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Subtotal = 9;
inline bool WorkItem::has_subtotal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WorkItem::set_has_subtotal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WorkItem::clear_has_subtotal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WorkItem::clear_subtotal() {
  if (subtotal_ != &::google::protobuf::internal::kEmptyString) {
    subtotal_->clear();
  }
  clear_has_subtotal();
}
inline const ::std::string& WorkItem::subtotal() const {
  return *subtotal_;
}
inline void WorkItem::set_subtotal(const ::std::string& value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::kEmptyString) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
}
inline void WorkItem::set_subtotal(const char* value) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::kEmptyString) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(value);
}
inline void WorkItem::set_subtotal(const char* value, size_t size) {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::kEmptyString) {
    subtotal_ = new ::std::string;
  }
  subtotal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_subtotal() {
  set_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::kEmptyString) {
    subtotal_ = new ::std::string;
  }
  return subtotal_;
}
inline ::std::string* WorkItem::release_subtotal() {
  clear_has_subtotal();
  if (subtotal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtotal_;
    subtotal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string AdditionalInfo = 10;
inline bool WorkItem::has_additionalinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WorkItem::set_has_additionalinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WorkItem::clear_has_additionalinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WorkItem::clear_additionalinfo() {
  if (additionalinfo_ != &::google::protobuf::internal::kEmptyString) {
    additionalinfo_->clear();
  }
  clear_has_additionalinfo();
}
inline const ::std::string& WorkItem::additionalinfo() const {
  return *additionalinfo_;
}
inline void WorkItem::set_additionalinfo(const ::std::string& value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void WorkItem::set_additionalinfo(const char* value) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(value);
}
inline void WorkItem::set_additionalinfo(const char* value, size_t size) {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  additionalinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkItem::mutable_additionalinfo() {
  set_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    additionalinfo_ = new ::std::string;
  }
  return additionalinfo_;
}
inline ::std::string* WorkItem::release_additionalinfo() {
  clear_has_additionalinfo();
  if (additionalinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalinfo_;
    additionalinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fAcceptanceCertificateInfo_2eproto__INCLUDED
