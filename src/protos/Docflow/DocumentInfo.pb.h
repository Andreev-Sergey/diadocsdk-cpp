// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Docflow/DocumentInfo.proto

#ifndef PROTOBUF_Docflow_2fDocumentInfo_2eproto__INCLUDED
#define PROTOBUF_Docflow_2fDocumentInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "DocumentType.pb.h"
#include "DocumentDirection.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Docflow {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();

class DocumentInfo;
class DocumentDateAndNumber;
class BasicDocumentInfo;
class InvoiceDocumentInfo;
class InvoiceCorrectionDocumentInfo;
class PriceListDocumentInfo;
class ContractDocumentInfo;
class SupplementaryAgreementDocumentInfo;

// ===================================================================

class DocumentInfo : public ::google::protobuf::Message {
 public:
  DocumentInfo();
  virtual ~DocumentInfo();
  
  DocumentInfo(const DocumentInfo& from);
  
  inline DocumentInfo& operator=(const DocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentInfo& default_instance();
  
  void Swap(DocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  DocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentInfo& from);
  void MergeFrom(const DocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Diadoc.Api.Proto.DocumentType DocumentType = 1 [default = UnknownDocumentType];
  inline bool has_documenttype() const;
  inline void clear_documenttype();
  static const int kDocumentTypeFieldNumber = 1;
  inline Diadoc::Api::Proto::DocumentType documenttype() const;
  inline void set_documenttype(Diadoc::Api::Proto::DocumentType value);
  
  // optional .Diadoc.Api.Proto.DocumentDirection DocumentDirection = 2 [default = UnknownDocumentDirection];
  inline bool has_documentdirection() const;
  inline void clear_documentdirection();
  static const int kDocumentDirectionFieldNumber = 2;
  inline Diadoc::Api::Proto::DocumentDirection documentdirection() const;
  inline void set_documentdirection(Diadoc::Api::Proto::DocumentDirection value);
  
  // optional bool IsTest = 3;
  inline bool has_istest() const;
  inline void clear_istest();
  static const int kIsTestFieldNumber = 3;
  inline bool istest() const;
  inline void set_istest(bool value);
  
  // optional string CustomDocumentId = 4;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 4;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  
  // optional string FromDepartmentId = 5;
  inline bool has_fromdepartmentid() const;
  inline void clear_fromdepartmentid();
  static const int kFromDepartmentIdFieldNumber = 5;
  inline const ::std::string& fromdepartmentid() const;
  inline void set_fromdepartmentid(const ::std::string& value);
  inline void set_fromdepartmentid(const char* value);
  inline void set_fromdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_fromdepartmentid();
  inline ::std::string* release_fromdepartmentid();
  
  // optional string ToDepartmentId = 6;
  inline bool has_todepartmentid() const;
  inline void clear_todepartmentid();
  static const int kToDepartmentIdFieldNumber = 6;
  inline const ::std::string& todepartmentid() const;
  inline void set_todepartmentid(const ::std::string& value);
  inline void set_todepartmentid(const char* value);
  inline void set_todepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_todepartmentid();
  inline ::std::string* release_todepartmentid();
  
  // optional string CounteragentBoxId = 7;
  inline bool has_counteragentboxid() const;
  inline void clear_counteragentboxid();
  static const int kCounteragentBoxIdFieldNumber = 7;
  inline const ::std::string& counteragentboxid() const;
  inline void set_counteragentboxid(const ::std::string& value);
  inline void set_counteragentboxid(const char* value);
  inline void set_counteragentboxid(const char* value, size_t size);
  inline ::std::string* mutable_counteragentboxid();
  inline ::std::string* release_counteragentboxid();
  
  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber DocumentDateAndNumber = 8;
  inline bool has_documentdateandnumber() const;
  inline void clear_documentdateandnumber();
  static const int kDocumentDateAndNumberFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& documentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_documentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_documentdateandnumber();
  
  // optional .Diadoc.Api.Proto.Docflow.BasicDocumentInfo BasicDocumentInfo = 9;
  inline bool has_basicdocumentinfo() const;
  inline void clear_basicdocumentinfo();
  static const int kBasicDocumentInfoFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo& basicdocumentinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* mutable_basicdocumentinfo();
  inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* release_basicdocumentinfo();
  
  // optional .Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo InvoiceInfo = 10;
  inline bool has_invoiceinfo() const;
  inline void clear_invoiceinfo();
  static const int kInvoiceInfoFieldNumber = 10;
  inline const ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo& invoiceinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* mutable_invoiceinfo();
  inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* release_invoiceinfo();
  
  // optional .Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo InvoiceCorrectionInfo = 11;
  inline bool has_invoicecorrectioninfo() const;
  inline void clear_invoicecorrectioninfo();
  static const int kInvoiceCorrectionInfoFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo& invoicecorrectioninfo() const;
  inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* mutable_invoicecorrectioninfo();
  inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* release_invoicecorrectioninfo();
  
  // optional .Diadoc.Api.Proto.Docflow.PriceListDocumentInfo PriceListInfo = 12;
  inline bool has_pricelistinfo() const;
  inline void clear_pricelistinfo();
  static const int kPriceListInfoFieldNumber = 12;
  inline const ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo& pricelistinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* mutable_pricelistinfo();
  inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* release_pricelistinfo();
  
  // optional .Diadoc.Api.Proto.Docflow.ContractDocumentInfo ContractInfo = 13;
  inline bool has_contractinfo() const;
  inline void clear_contractinfo();
  static const int kContractInfoFieldNumber = 13;
  inline const ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo& contractinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* mutable_contractinfo();
  inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* release_contractinfo();
  
  // optional .Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo SupplementaryAgreementInfo = 14;
  inline bool has_supplementaryagreementinfo() const;
  inline void clear_supplementaryagreementinfo();
  static const int kSupplementaryAgreementInfoFieldNumber = 14;
  inline const ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo& supplementaryagreementinfo() const;
  inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* mutable_supplementaryagreementinfo();
  inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* release_supplementaryagreementinfo();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.DocumentInfo)
 private:
  inline void set_has_documenttype();
  inline void clear_has_documenttype();
  inline void set_has_documentdirection();
  inline void clear_has_documentdirection();
  inline void set_has_istest();
  inline void clear_has_istest();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_fromdepartmentid();
  inline void clear_has_fromdepartmentid();
  inline void set_has_todepartmentid();
  inline void clear_has_todepartmentid();
  inline void set_has_counteragentboxid();
  inline void clear_has_counteragentboxid();
  inline void set_has_documentdateandnumber();
  inline void clear_has_documentdateandnumber();
  inline void set_has_basicdocumentinfo();
  inline void clear_has_basicdocumentinfo();
  inline void set_has_invoiceinfo();
  inline void clear_has_invoiceinfo();
  inline void set_has_invoicecorrectioninfo();
  inline void clear_has_invoicecorrectioninfo();
  inline void set_has_pricelistinfo();
  inline void clear_has_pricelistinfo();
  inline void set_has_contractinfo();
  inline void clear_has_contractinfo();
  inline void set_has_supplementaryagreementinfo();
  inline void clear_has_supplementaryagreementinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int documenttype_;
  int documentdirection_;
  ::std::string* customdocumentid_;
  ::std::string* fromdepartmentid_;
  ::std::string* todepartmentid_;
  ::std::string* counteragentboxid_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* documentdateandnumber_;
  ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* basicdocumentinfo_;
  ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* invoiceinfo_;
  ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* invoicecorrectioninfo_;
  ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* pricelistinfo_;
  ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* contractinfo_;
  ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* supplementaryagreementinfo_;
  bool istest_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static DocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class DocumentDateAndNumber : public ::google::protobuf::Message {
 public:
  DocumentDateAndNumber();
  virtual ~DocumentDateAndNumber();
  
  DocumentDateAndNumber(const DocumentDateAndNumber& from);
  
  inline DocumentDateAndNumber& operator=(const DocumentDateAndNumber& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentDateAndNumber& default_instance();
  
  void Swap(DocumentDateAndNumber* other);
  
  // implements Message ----------------------------------------------
  
  DocumentDateAndNumber* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentDateAndNumber& from);
  void MergeFrom(const DocumentDateAndNumber& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string DocumentDate = 1;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 1;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  
  // optional string DocumentNumber = 2;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 2;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.DocumentDateAndNumber)
 private:
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static DocumentDateAndNumber* default_instance_;
};
// -------------------------------------------------------------------

class BasicDocumentInfo : public ::google::protobuf::Message {
 public:
  BasicDocumentInfo();
  virtual ~BasicDocumentInfo();
  
  BasicDocumentInfo(const BasicDocumentInfo& from);
  
  inline BasicDocumentInfo& operator=(const BasicDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicDocumentInfo& default_instance();
  
  void Swap(BasicDocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  BasicDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicDocumentInfo& from);
  void MergeFrom(const BasicDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  
  // optional bool NoVat = 2;
  inline bool has_novat() const;
  inline void clear_novat();
  static const int kNoVatFieldNumber = 2;
  inline bool novat() const;
  inline void set_novat(bool value);
  
  // optional string Vat = 3;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 3;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  
  // optional string Grounds = 4;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 4;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.BasicDocumentInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_novat();
  inline void clear_has_novat();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* total_;
  ::std::string* vat_;
  ::std::string* grounds_;
  bool novat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BasicDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceDocumentInfo : public ::google::protobuf::Message {
 public:
  InvoiceDocumentInfo();
  virtual ~InvoiceDocumentInfo();
  
  InvoiceDocumentInfo(const InvoiceDocumentInfo& from);
  
  inline InvoiceDocumentInfo& operator=(const InvoiceDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceDocumentInfo& default_instance();
  
  void Swap(InvoiceDocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  InvoiceDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceDocumentInfo& from);
  void MergeFrom(const InvoiceDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  
  // optional string Vat = 2;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 2;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  
  // optional int32 CurrencyCode = 3;
  inline bool has_currencycode() const;
  inline void clear_currencycode();
  static const int kCurrencyCodeFieldNumber = 3;
  inline ::google::protobuf::int32 currencycode() const;
  inline void set_currencycode(::google::protobuf::int32 value);
  
  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 4;
  inline bool has_originalinvoicedateandnumber() const;
  inline void clear_originalinvoicedateandnumber();
  static const int kOriginalInvoiceDateAndNumberFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicedateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicedateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicedateandnumber();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_currencycode();
  inline void clear_has_currencycode();
  inline void set_has_originalinvoicedateandnumber();
  inline void clear_has_originalinvoicedateandnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* total_;
  ::std::string* vat_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber_;
  ::google::protobuf::int32 currencycode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static InvoiceDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class InvoiceCorrectionDocumentInfo : public ::google::protobuf::Message {
 public:
  InvoiceCorrectionDocumentInfo();
  virtual ~InvoiceCorrectionDocumentInfo();
  
  InvoiceCorrectionDocumentInfo(const InvoiceCorrectionDocumentInfo& from);
  
  inline InvoiceCorrectionDocumentInfo& operator=(const InvoiceCorrectionDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvoiceCorrectionDocumentInfo& default_instance();
  
  void Swap(InvoiceCorrectionDocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  InvoiceCorrectionDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvoiceCorrectionDocumentInfo& from);
  void MergeFrom(const InvoiceCorrectionDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string TotalInc = 1;
  inline bool has_totalinc() const;
  inline void clear_totalinc();
  static const int kTotalIncFieldNumber = 1;
  inline const ::std::string& totalinc() const;
  inline void set_totalinc(const ::std::string& value);
  inline void set_totalinc(const char* value);
  inline void set_totalinc(const char* value, size_t size);
  inline ::std::string* mutable_totalinc();
  inline ::std::string* release_totalinc();
  
  // optional string TotalDec = 2;
  inline bool has_totaldec() const;
  inline void clear_totaldec();
  static const int kTotalDecFieldNumber = 2;
  inline const ::std::string& totaldec() const;
  inline void set_totaldec(const ::std::string& value);
  inline void set_totaldec(const char* value);
  inline void set_totaldec(const char* value, size_t size);
  inline ::std::string* mutable_totaldec();
  inline ::std::string* release_totaldec();
  
  // optional string VatInc = 3;
  inline bool has_vatinc() const;
  inline void clear_vatinc();
  static const int kVatIncFieldNumber = 3;
  inline const ::std::string& vatinc() const;
  inline void set_vatinc(const ::std::string& value);
  inline void set_vatinc(const char* value);
  inline void set_vatinc(const char* value, size_t size);
  inline ::std::string* mutable_vatinc();
  inline ::std::string* release_vatinc();
  
  // optional string VatDec = 4;
  inline bool has_vatdec() const;
  inline void clear_vatdec();
  static const int kVatDecFieldNumber = 4;
  inline const ::std::string& vatdec() const;
  inline void set_vatdec(const ::std::string& value);
  inline void set_vatdec(const char* value);
  inline void set_vatdec(const char* value, size_t size);
  inline ::std::string* mutable_vatdec();
  inline ::std::string* release_vatdec();
  
  // optional int32 CurrencyCode = 5;
  inline bool has_currencycode() const;
  inline void clear_currencycode();
  static const int kCurrencyCodeFieldNumber = 5;
  inline ::google::protobuf::int32 currencycode() const;
  inline void set_currencycode(::google::protobuf::int32 value);
  
  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 6;
  inline bool has_originalinvoicedateandnumber() const;
  inline void clear_originalinvoicedateandnumber();
  static const int kOriginalInvoiceDateAndNumberFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicedateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicedateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicedateandnumber();
  
  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceRevisionDateAndNumber = 7;
  inline bool has_originalinvoicerevisiondateandnumber() const;
  inline void clear_originalinvoicerevisiondateandnumber();
  static const int kOriginalInvoiceRevisionDateAndNumberFieldNumber = 7;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicerevisiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicerevisiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicerevisiondateandnumber();
  
  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceCorrectionDateAndNumber = 8;
  inline bool has_originalinvoicecorrectiondateandnumber() const;
  inline void clear_originalinvoicecorrectiondateandnumber();
  static const int kOriginalInvoiceCorrectionDateAndNumberFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& originalinvoicecorrectiondateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_originalinvoicecorrectiondateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_originalinvoicecorrectiondateandnumber();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo)
 private:
  inline void set_has_totalinc();
  inline void clear_has_totalinc();
  inline void set_has_totaldec();
  inline void clear_has_totaldec();
  inline void set_has_vatinc();
  inline void clear_has_vatinc();
  inline void set_has_vatdec();
  inline void clear_has_vatdec();
  inline void set_has_currencycode();
  inline void clear_has_currencycode();
  inline void set_has_originalinvoicedateandnumber();
  inline void clear_has_originalinvoicedateandnumber();
  inline void set_has_originalinvoicerevisiondateandnumber();
  inline void clear_has_originalinvoicerevisiondateandnumber();
  inline void set_has_originalinvoicecorrectiondateandnumber();
  inline void clear_has_originalinvoicecorrectiondateandnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* totalinc_;
  ::std::string* totaldec_;
  ::std::string* vatinc_;
  ::std::string* vatdec_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicedateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicerevisiondateandnumber_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* originalinvoicecorrectiondateandnumber_;
  ::google::protobuf::int32 currencycode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static InvoiceCorrectionDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class PriceListDocumentInfo : public ::google::protobuf::Message {
 public:
  PriceListDocumentInfo();
  virtual ~PriceListDocumentInfo();
  
  PriceListDocumentInfo(const PriceListDocumentInfo& from);
  
  inline PriceListDocumentInfo& operator=(const PriceListDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceListDocumentInfo& default_instance();
  
  void Swap(PriceListDocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  PriceListDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceListDocumentInfo& from);
  void MergeFrom(const PriceListDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string PriceListEffectiveDate = 1;
  inline bool has_pricelisteffectivedate() const;
  inline void clear_pricelisteffectivedate();
  static const int kPriceListEffectiveDateFieldNumber = 1;
  inline const ::std::string& pricelisteffectivedate() const;
  inline void set_pricelisteffectivedate(const ::std::string& value);
  inline void set_pricelisteffectivedate(const char* value);
  inline void set_pricelisteffectivedate(const char* value, size_t size);
  inline ::std::string* mutable_pricelisteffectivedate();
  inline ::std::string* release_pricelisteffectivedate();
  
  // optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber ContractDocumentDateAndNumber = 2;
  inline bool has_contractdocumentdateandnumber() const;
  inline void clear_contractdocumentdateandnumber();
  static const int kContractDocumentDateAndNumberFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& contractdocumentdateandnumber() const;
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* mutable_contractdocumentdateandnumber();
  inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* release_contractdocumentdateandnumber();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.PriceListDocumentInfo)
 private:
  inline void set_has_pricelisteffectivedate();
  inline void clear_has_pricelisteffectivedate();
  inline void set_has_contractdocumentdateandnumber();
  inline void clear_has_contractdocumentdateandnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pricelisteffectivedate_;
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* contractdocumentdateandnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static PriceListDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContractDocumentInfo : public ::google::protobuf::Message {
 public:
  ContractDocumentInfo();
  virtual ~ContractDocumentInfo();
  
  ContractDocumentInfo(const ContractDocumentInfo& from);
  
  inline ContractDocumentInfo& operator=(const ContractDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContractDocumentInfo& default_instance();
  
  void Swap(ContractDocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  ContractDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContractDocumentInfo& from);
  void MergeFrom(const ContractDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ContractPrice = 1;
  inline bool has_contractprice() const;
  inline void clear_contractprice();
  static const int kContractPriceFieldNumber = 1;
  inline const ::std::string& contractprice() const;
  inline void set_contractprice(const ::std::string& value);
  inline void set_contractprice(const char* value);
  inline void set_contractprice(const char* value, size_t size);
  inline ::std::string* mutable_contractprice();
  inline ::std::string* release_contractprice();
  
  // optional string ContractType = 2;
  inline bool has_contracttype() const;
  inline void clear_contracttype();
  static const int kContractTypeFieldNumber = 2;
  inline const ::std::string& contracttype() const;
  inline void set_contracttype(const ::std::string& value);
  inline void set_contracttype(const char* value);
  inline void set_contracttype(const char* value, size_t size);
  inline ::std::string* mutable_contracttype();
  inline ::std::string* release_contracttype();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.ContractDocumentInfo)
 private:
  inline void set_has_contractprice();
  inline void clear_has_contractprice();
  inline void set_has_contracttype();
  inline void clear_has_contracttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* contractprice_;
  ::std::string* contracttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static ContractDocumentInfo* default_instance_;
};
// -------------------------------------------------------------------

class SupplementaryAgreementDocumentInfo : public ::google::protobuf::Message {
 public:
  SupplementaryAgreementDocumentInfo();
  virtual ~SupplementaryAgreementDocumentInfo();
  
  SupplementaryAgreementDocumentInfo(const SupplementaryAgreementDocumentInfo& from);
  
  inline SupplementaryAgreementDocumentInfo& operator=(const SupplementaryAgreementDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SupplementaryAgreementDocumentInfo& default_instance();
  
  void Swap(SupplementaryAgreementDocumentInfo* other);
  
  // implements Message ----------------------------------------------
  
  SupplementaryAgreementDocumentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SupplementaryAgreementDocumentInfo& from);
  void MergeFrom(const SupplementaryAgreementDocumentInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string Total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  
  // optional string ContractType = 2;
  inline bool has_contracttype() const;
  inline void clear_contracttype();
  static const int kContractTypeFieldNumber = 2;
  inline const ::std::string& contracttype() const;
  inline void set_contracttype(const ::std::string& value);
  inline void set_contracttype(const char* value);
  inline void set_contracttype(const char* value, size_t size);
  inline ::std::string* mutable_contracttype();
  inline ::std::string* release_contracttype();
  
  // optional string ContractNumber = 3;
  inline bool has_contractnumber() const;
  inline void clear_contractnumber();
  static const int kContractNumberFieldNumber = 3;
  inline const ::std::string& contractnumber() const;
  inline void set_contractnumber(const ::std::string& value);
  inline void set_contractnumber(const char* value);
  inline void set_contractnumber(const char* value, size_t size);
  inline ::std::string* mutable_contractnumber();
  inline ::std::string* release_contractnumber();
  
  // optional string ContractDate = 4;
  inline bool has_contractdate() const;
  inline void clear_contractdate();
  static const int kContractDateFieldNumber = 4;
  inline const ::std::string& contractdate() const;
  inline void set_contractdate(const ::std::string& value);
  inline void set_contractdate(const char* value);
  inline void set_contractdate(const char* value, size_t size);
  inline ::std::string* mutable_contractdate();
  inline ::std::string* release_contractdate();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_contracttype();
  inline void clear_has_contracttype();
  inline void set_has_contractnumber();
  inline void clear_has_contractnumber();
  inline void set_has_contractdate();
  inline void clear_has_contractdate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* total_;
  ::std::string* contracttype_;
  ::std::string* contractnumber_;
  ::std::string* contractdate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_AssignDesc_Docflow_2fDocumentInfo_2eproto();
  friend void protobuf_ShutdownFile_Docflow_2fDocumentInfo_2eproto();
  
  void InitAsDefaultInstance();
  static SupplementaryAgreementDocumentInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// DocumentInfo

// optional .Diadoc.Api.Proto.DocumentType DocumentType = 1 [default = UnknownDocumentType];
inline bool DocumentInfo::has_documenttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentInfo::set_has_documenttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentInfo::clear_has_documenttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentInfo::clear_documenttype() {
  documenttype_ = -1;
  clear_has_documenttype();
}
inline Diadoc::Api::Proto::DocumentType DocumentInfo::documenttype() const {
  return static_cast< Diadoc::Api::Proto::DocumentType >(documenttype_);
}
inline void DocumentInfo::set_documenttype(Diadoc::Api::Proto::DocumentType value) {
  GOOGLE_DCHECK(Diadoc::Api::Proto::DocumentType_IsValid(value));
  set_has_documenttype();
  documenttype_ = value;
}

// optional .Diadoc.Api.Proto.DocumentDirection DocumentDirection = 2 [default = UnknownDocumentDirection];
inline bool DocumentInfo::has_documentdirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentInfo::set_has_documentdirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentInfo::clear_has_documentdirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentInfo::clear_documentdirection() {
  documentdirection_ = 0;
  clear_has_documentdirection();
}
inline Diadoc::Api::Proto::DocumentDirection DocumentInfo::documentdirection() const {
  return static_cast< Diadoc::Api::Proto::DocumentDirection >(documentdirection_);
}
inline void DocumentInfo::set_documentdirection(Diadoc::Api::Proto::DocumentDirection value) {
  GOOGLE_DCHECK(Diadoc::Api::Proto::DocumentDirection_IsValid(value));
  set_has_documentdirection();
  documentdirection_ = value;
}

// optional bool IsTest = 3;
inline bool DocumentInfo::has_istest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentInfo::set_has_istest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentInfo::clear_has_istest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentInfo::clear_istest() {
  istest_ = false;
  clear_has_istest();
}
inline bool DocumentInfo::istest() const {
  return istest_;
}
inline void DocumentInfo::set_istest(bool value) {
  set_has_istest();
  istest_ = value;
}

// optional string CustomDocumentId = 4;
inline bool DocumentInfo::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentInfo::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentInfo::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentInfo::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& DocumentInfo::customdocumentid() const {
  return *customdocumentid_;
}
inline void DocumentInfo::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void DocumentInfo::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void DocumentInfo::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentInfo::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* DocumentInfo::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string FromDepartmentId = 5;
inline bool DocumentInfo::has_fromdepartmentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentInfo::set_has_fromdepartmentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocumentInfo::clear_has_fromdepartmentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocumentInfo::clear_fromdepartmentid() {
  if (fromdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_->clear();
  }
  clear_has_fromdepartmentid();
}
inline const ::std::string& DocumentInfo::fromdepartmentid() const {
  return *fromdepartmentid_;
}
inline void DocumentInfo::set_fromdepartmentid(const ::std::string& value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
}
inline void DocumentInfo::set_fromdepartmentid(const char* value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
}
inline void DocumentInfo::set_fromdepartmentid(const char* value, size_t size) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentInfo::mutable_fromdepartmentid() {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  return fromdepartmentid_;
}
inline ::std::string* DocumentInfo::release_fromdepartmentid() {
  clear_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromdepartmentid_;
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ToDepartmentId = 6;
inline bool DocumentInfo::has_todepartmentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocumentInfo::set_has_todepartmentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DocumentInfo::clear_has_todepartmentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DocumentInfo::clear_todepartmentid() {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    todepartmentid_->clear();
  }
  clear_has_todepartmentid();
}
inline const ::std::string& DocumentInfo::todepartmentid() const {
  return *todepartmentid_;
}
inline void DocumentInfo::set_todepartmentid(const ::std::string& value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void DocumentInfo::set_todepartmentid(const char* value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void DocumentInfo::set_todepartmentid(const char* value, size_t size) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentInfo::mutable_todepartmentid() {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  return todepartmentid_;
}
inline ::std::string* DocumentInfo::release_todepartmentid() {
  clear_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todepartmentid_;
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CounteragentBoxId = 7;
inline bool DocumentInfo::has_counteragentboxid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentInfo::set_has_counteragentboxid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DocumentInfo::clear_has_counteragentboxid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DocumentInfo::clear_counteragentboxid() {
  if (counteragentboxid_ != &::google::protobuf::internal::kEmptyString) {
    counteragentboxid_->clear();
  }
  clear_has_counteragentboxid();
}
inline const ::std::string& DocumentInfo::counteragentboxid() const {
  return *counteragentboxid_;
}
inline void DocumentInfo::set_counteragentboxid(const ::std::string& value) {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::kEmptyString) {
    counteragentboxid_ = new ::std::string;
  }
  counteragentboxid_->assign(value);
}
inline void DocumentInfo::set_counteragentboxid(const char* value) {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::kEmptyString) {
    counteragentboxid_ = new ::std::string;
  }
  counteragentboxid_->assign(value);
}
inline void DocumentInfo::set_counteragentboxid(const char* value, size_t size) {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::kEmptyString) {
    counteragentboxid_ = new ::std::string;
  }
  counteragentboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentInfo::mutable_counteragentboxid() {
  set_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::kEmptyString) {
    counteragentboxid_ = new ::std::string;
  }
  return counteragentboxid_;
}
inline ::std::string* DocumentInfo::release_counteragentboxid() {
  clear_has_counteragentboxid();
  if (counteragentboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = counteragentboxid_;
    counteragentboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber DocumentDateAndNumber = 8;
inline bool DocumentInfo::has_documentdateandnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DocumentInfo::set_has_documentdateandnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DocumentInfo::clear_has_documentdateandnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DocumentInfo::clear_documentdateandnumber() {
  if (documentdateandnumber_ != NULL) documentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_documentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& DocumentInfo::documentdateandnumber() const {
  return documentdateandnumber_ != NULL ? *documentdateandnumber_ : *default_instance_->documentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* DocumentInfo::mutable_documentdateandnumber() {
  set_has_documentdateandnumber();
  if (documentdateandnumber_ == NULL) documentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  return documentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* DocumentInfo::release_documentdateandnumber() {
  clear_has_documentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = documentdateandnumber_;
  documentdateandnumber_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.BasicDocumentInfo BasicDocumentInfo = 9;
inline bool DocumentInfo::has_basicdocumentinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DocumentInfo::set_has_basicdocumentinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DocumentInfo::clear_has_basicdocumentinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DocumentInfo::clear_basicdocumentinfo() {
  if (basicdocumentinfo_ != NULL) basicdocumentinfo_->::Diadoc::Api::Proto::Docflow::BasicDocumentInfo::Clear();
  clear_has_basicdocumentinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo& DocumentInfo::basicdocumentinfo() const {
  return basicdocumentinfo_ != NULL ? *basicdocumentinfo_ : *default_instance_->basicdocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* DocumentInfo::mutable_basicdocumentinfo() {
  set_has_basicdocumentinfo();
  if (basicdocumentinfo_ == NULL) basicdocumentinfo_ = new ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo;
  return basicdocumentinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* DocumentInfo::release_basicdocumentinfo() {
  clear_has_basicdocumentinfo();
  ::Diadoc::Api::Proto::Docflow::BasicDocumentInfo* temp = basicdocumentinfo_;
  basicdocumentinfo_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.InvoiceDocumentInfo InvoiceInfo = 10;
inline bool DocumentInfo::has_invoiceinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DocumentInfo::set_has_invoiceinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DocumentInfo::clear_has_invoiceinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DocumentInfo::clear_invoiceinfo() {
  if (invoiceinfo_ != NULL) invoiceinfo_->::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo::Clear();
  clear_has_invoiceinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo& DocumentInfo::invoiceinfo() const {
  return invoiceinfo_ != NULL ? *invoiceinfo_ : *default_instance_->invoiceinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* DocumentInfo::mutable_invoiceinfo() {
  set_has_invoiceinfo();
  if (invoiceinfo_ == NULL) invoiceinfo_ = new ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo;
  return invoiceinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* DocumentInfo::release_invoiceinfo() {
  clear_has_invoiceinfo();
  ::Diadoc::Api::Proto::Docflow::InvoiceDocumentInfo* temp = invoiceinfo_;
  invoiceinfo_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.InvoiceCorrectionDocumentInfo InvoiceCorrectionInfo = 11;
inline bool DocumentInfo::has_invoicecorrectioninfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DocumentInfo::set_has_invoicecorrectioninfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DocumentInfo::clear_has_invoicecorrectioninfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DocumentInfo::clear_invoicecorrectioninfo() {
  if (invoicecorrectioninfo_ != NULL) invoicecorrectioninfo_->::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo::Clear();
  clear_has_invoicecorrectioninfo();
}
inline const ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo& DocumentInfo::invoicecorrectioninfo() const {
  return invoicecorrectioninfo_ != NULL ? *invoicecorrectioninfo_ : *default_instance_->invoicecorrectioninfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* DocumentInfo::mutable_invoicecorrectioninfo() {
  set_has_invoicecorrectioninfo();
  if (invoicecorrectioninfo_ == NULL) invoicecorrectioninfo_ = new ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo;
  return invoicecorrectioninfo_;
}
inline ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* DocumentInfo::release_invoicecorrectioninfo() {
  clear_has_invoicecorrectioninfo();
  ::Diadoc::Api::Proto::Docflow::InvoiceCorrectionDocumentInfo* temp = invoicecorrectioninfo_;
  invoicecorrectioninfo_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.PriceListDocumentInfo PriceListInfo = 12;
inline bool DocumentInfo::has_pricelistinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DocumentInfo::set_has_pricelistinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DocumentInfo::clear_has_pricelistinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DocumentInfo::clear_pricelistinfo() {
  if (pricelistinfo_ != NULL) pricelistinfo_->::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo::Clear();
  clear_has_pricelistinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo& DocumentInfo::pricelistinfo() const {
  return pricelistinfo_ != NULL ? *pricelistinfo_ : *default_instance_->pricelistinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* DocumentInfo::mutable_pricelistinfo() {
  set_has_pricelistinfo();
  if (pricelistinfo_ == NULL) pricelistinfo_ = new ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo;
  return pricelistinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* DocumentInfo::release_pricelistinfo() {
  clear_has_pricelistinfo();
  ::Diadoc::Api::Proto::Docflow::PriceListDocumentInfo* temp = pricelistinfo_;
  pricelistinfo_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.ContractDocumentInfo ContractInfo = 13;
inline bool DocumentInfo::has_contractinfo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DocumentInfo::set_has_contractinfo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DocumentInfo::clear_has_contractinfo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DocumentInfo::clear_contractinfo() {
  if (contractinfo_ != NULL) contractinfo_->::Diadoc::Api::Proto::Docflow::ContractDocumentInfo::Clear();
  clear_has_contractinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo& DocumentInfo::contractinfo() const {
  return contractinfo_ != NULL ? *contractinfo_ : *default_instance_->contractinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* DocumentInfo::mutable_contractinfo() {
  set_has_contractinfo();
  if (contractinfo_ == NULL) contractinfo_ = new ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo;
  return contractinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* DocumentInfo::release_contractinfo() {
  clear_has_contractinfo();
  ::Diadoc::Api::Proto::Docflow::ContractDocumentInfo* temp = contractinfo_;
  contractinfo_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.SupplementaryAgreementDocumentInfo SupplementaryAgreementInfo = 14;
inline bool DocumentInfo::has_supplementaryagreementinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DocumentInfo::set_has_supplementaryagreementinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DocumentInfo::clear_has_supplementaryagreementinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DocumentInfo::clear_supplementaryagreementinfo() {
  if (supplementaryagreementinfo_ != NULL) supplementaryagreementinfo_->::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo::Clear();
  clear_has_supplementaryagreementinfo();
}
inline const ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo& DocumentInfo::supplementaryagreementinfo() const {
  return supplementaryagreementinfo_ != NULL ? *supplementaryagreementinfo_ : *default_instance_->supplementaryagreementinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* DocumentInfo::mutable_supplementaryagreementinfo() {
  set_has_supplementaryagreementinfo();
  if (supplementaryagreementinfo_ == NULL) supplementaryagreementinfo_ = new ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo;
  return supplementaryagreementinfo_;
}
inline ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* DocumentInfo::release_supplementaryagreementinfo() {
  clear_has_supplementaryagreementinfo();
  ::Diadoc::Api::Proto::Docflow::SupplementaryAgreementDocumentInfo* temp = supplementaryagreementinfo_;
  supplementaryagreementinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DocumentDateAndNumber

// optional string DocumentDate = 1;
inline bool DocumentDateAndNumber::has_documentdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentDateAndNumber::set_has_documentdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentDateAndNumber::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentDateAndNumber::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& DocumentDateAndNumber::documentdate() const {
  return *documentdate_;
}
inline void DocumentDateAndNumber::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void DocumentDateAndNumber::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void DocumentDateAndNumber::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentDateAndNumber::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* DocumentDateAndNumber::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DocumentNumber = 2;
inline bool DocumentDateAndNumber::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentDateAndNumber::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentDateAndNumber::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentDateAndNumber::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& DocumentDateAndNumber::documentnumber() const {
  return *documentnumber_;
}
inline void DocumentDateAndNumber::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void DocumentDateAndNumber::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void DocumentDateAndNumber::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentDateAndNumber::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* DocumentDateAndNumber::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BasicDocumentInfo

// optional string Total = 1;
inline bool BasicDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& BasicDocumentInfo::total() const {
  return *total_;
}
inline void BasicDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void BasicDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void BasicDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* BasicDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool NoVat = 2;
inline bool BasicDocumentInfo::has_novat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicDocumentInfo::set_has_novat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicDocumentInfo::clear_has_novat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicDocumentInfo::clear_novat() {
  novat_ = false;
  clear_has_novat();
}
inline bool BasicDocumentInfo::novat() const {
  return novat_;
}
inline void BasicDocumentInfo::set_novat(bool value) {
  set_has_novat();
  novat_ = value;
}

// optional string Vat = 3;
inline bool BasicDocumentInfo::has_vat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicDocumentInfo::set_has_vat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicDocumentInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicDocumentInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& BasicDocumentInfo::vat() const {
  return *vat_;
}
inline void BasicDocumentInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void BasicDocumentInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void BasicDocumentInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* BasicDocumentInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Grounds = 4;
inline bool BasicDocumentInfo::has_grounds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasicDocumentInfo::set_has_grounds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasicDocumentInfo::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasicDocumentInfo::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& BasicDocumentInfo::grounds() const {
  return *grounds_;
}
inline void BasicDocumentInfo::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void BasicDocumentInfo::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void BasicDocumentInfo::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentInfo::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  return grounds_;
}
inline ::std::string* BasicDocumentInfo::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvoiceDocumentInfo

// optional string Total = 1;
inline bool InvoiceDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& InvoiceDocumentInfo::total() const {
  return *total_;
}
inline void InvoiceDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void InvoiceDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void InvoiceDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvoiceDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* InvoiceDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Vat = 2;
inline bool InvoiceDocumentInfo::has_vat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceDocumentInfo::set_has_vat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceDocumentInfo::clear_has_vat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceDocumentInfo::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& InvoiceDocumentInfo::vat() const {
  return *vat_;
}
inline void InvoiceDocumentInfo::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void InvoiceDocumentInfo::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void InvoiceDocumentInfo::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvoiceDocumentInfo::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* InvoiceDocumentInfo::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 CurrencyCode = 3;
inline bool InvoiceDocumentInfo::has_currencycode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceDocumentInfo::set_has_currencycode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceDocumentInfo::clear_has_currencycode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceDocumentInfo::clear_currencycode() {
  currencycode_ = 0;
  clear_has_currencycode();
}
inline ::google::protobuf::int32 InvoiceDocumentInfo::currencycode() const {
  return currencycode_;
}
inline void InvoiceDocumentInfo::set_currencycode(::google::protobuf::int32 value) {
  set_has_currencycode();
  currencycode_ = value;
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 4;
inline bool InvoiceDocumentInfo::has_originalinvoicedateandnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceDocumentInfo::set_has_originalinvoicedateandnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceDocumentInfo::clear_has_originalinvoicedateandnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceDocumentInfo::clear_originalinvoicedateandnumber() {
  if (originalinvoicedateandnumber_ != NULL) originalinvoicedateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicedateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceDocumentInfo::originalinvoicedateandnumber() const {
  return originalinvoicedateandnumber_ != NULL ? *originalinvoicedateandnumber_ : *default_instance_->originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceDocumentInfo::mutable_originalinvoicedateandnumber() {
  set_has_originalinvoicedateandnumber();
  if (originalinvoicedateandnumber_ == NULL) originalinvoicedateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  return originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceDocumentInfo::release_originalinvoicedateandnumber() {
  clear_has_originalinvoicedateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicedateandnumber_;
  originalinvoicedateandnumber_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// InvoiceCorrectionDocumentInfo

// optional string TotalInc = 1;
inline bool InvoiceCorrectionDocumentInfo::has_totalinc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_totalinc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_totalinc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvoiceCorrectionDocumentInfo::clear_totalinc() {
  if (totalinc_ != &::google::protobuf::internal::kEmptyString) {
    totalinc_->clear();
  }
  clear_has_totalinc();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::totalinc() const {
  return *totalinc_;
}
inline void InvoiceCorrectionDocumentInfo::set_totalinc(const ::std::string& value) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::kEmptyString) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_totalinc(const char* value) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::kEmptyString) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_totalinc(const char* value, size_t size) {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::kEmptyString) {
    totalinc_ = new ::std::string;
  }
  totalinc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_totalinc() {
  set_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::kEmptyString) {
    totalinc_ = new ::std::string;
  }
  return totalinc_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_totalinc() {
  clear_has_totalinc();
  if (totalinc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totalinc_;
    totalinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TotalDec = 2;
inline bool InvoiceCorrectionDocumentInfo::has_totaldec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_totaldec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_totaldec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvoiceCorrectionDocumentInfo::clear_totaldec() {
  if (totaldec_ != &::google::protobuf::internal::kEmptyString) {
    totaldec_->clear();
  }
  clear_has_totaldec();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::totaldec() const {
  return *totaldec_;
}
inline void InvoiceCorrectionDocumentInfo::set_totaldec(const ::std::string& value) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::kEmptyString) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_totaldec(const char* value) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::kEmptyString) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_totaldec(const char* value, size_t size) {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::kEmptyString) {
    totaldec_ = new ::std::string;
  }
  totaldec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_totaldec() {
  set_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::kEmptyString) {
    totaldec_ = new ::std::string;
  }
  return totaldec_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_totaldec() {
  clear_has_totaldec();
  if (totaldec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totaldec_;
    totaldec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string VatInc = 3;
inline bool InvoiceCorrectionDocumentInfo::has_vatinc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_vatinc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_vatinc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvoiceCorrectionDocumentInfo::clear_vatinc() {
  if (vatinc_ != &::google::protobuf::internal::kEmptyString) {
    vatinc_->clear();
  }
  clear_has_vatinc();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::vatinc() const {
  return *vatinc_;
}
inline void InvoiceCorrectionDocumentInfo::set_vatinc(const ::std::string& value) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::kEmptyString) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_vatinc(const char* value) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::kEmptyString) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_vatinc(const char* value, size_t size) {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::kEmptyString) {
    vatinc_ = new ::std::string;
  }
  vatinc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_vatinc() {
  set_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::kEmptyString) {
    vatinc_ = new ::std::string;
  }
  return vatinc_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_vatinc() {
  clear_has_vatinc();
  if (vatinc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vatinc_;
    vatinc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string VatDec = 4;
inline bool InvoiceCorrectionDocumentInfo::has_vatdec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_vatdec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_vatdec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvoiceCorrectionDocumentInfo::clear_vatdec() {
  if (vatdec_ != &::google::protobuf::internal::kEmptyString) {
    vatdec_->clear();
  }
  clear_has_vatdec();
}
inline const ::std::string& InvoiceCorrectionDocumentInfo::vatdec() const {
  return *vatdec_;
}
inline void InvoiceCorrectionDocumentInfo::set_vatdec(const ::std::string& value) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::kEmptyString) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_vatdec(const char* value) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::kEmptyString) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(value);
}
inline void InvoiceCorrectionDocumentInfo::set_vatdec(const char* value, size_t size) {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::kEmptyString) {
    vatdec_ = new ::std::string;
  }
  vatdec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvoiceCorrectionDocumentInfo::mutable_vatdec() {
  set_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::kEmptyString) {
    vatdec_ = new ::std::string;
  }
  return vatdec_;
}
inline ::std::string* InvoiceCorrectionDocumentInfo::release_vatdec() {
  clear_has_vatdec();
  if (vatdec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vatdec_;
    vatdec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 CurrencyCode = 5;
inline bool InvoiceCorrectionDocumentInfo::has_currencycode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_currencycode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_currencycode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvoiceCorrectionDocumentInfo::clear_currencycode() {
  currencycode_ = 0;
  clear_has_currencycode();
}
inline ::google::protobuf::int32 InvoiceCorrectionDocumentInfo::currencycode() const {
  return currencycode_;
}
inline void InvoiceCorrectionDocumentInfo::set_currencycode(::google::protobuf::int32 value) {
  set_has_currencycode();
  currencycode_ = value;
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceDateAndNumber = 6;
inline bool InvoiceCorrectionDocumentInfo::has_originalinvoicedateandnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_originalinvoicedateandnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_originalinvoicedateandnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvoiceCorrectionDocumentInfo::clear_originalinvoicedateandnumber() {
  if (originalinvoicedateandnumber_ != NULL) originalinvoicedateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicedateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceCorrectionDocumentInfo::originalinvoicedateandnumber() const {
  return originalinvoicedateandnumber_ != NULL ? *originalinvoicedateandnumber_ : *default_instance_->originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::mutable_originalinvoicedateandnumber() {
  set_has_originalinvoicedateandnumber();
  if (originalinvoicedateandnumber_ == NULL) originalinvoicedateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  return originalinvoicedateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::release_originalinvoicedateandnumber() {
  clear_has_originalinvoicedateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicedateandnumber_;
  originalinvoicedateandnumber_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceRevisionDateAndNumber = 7;
inline bool InvoiceCorrectionDocumentInfo::has_originalinvoicerevisiondateandnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_originalinvoicerevisiondateandnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_originalinvoicerevisiondateandnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvoiceCorrectionDocumentInfo::clear_originalinvoicerevisiondateandnumber() {
  if (originalinvoicerevisiondateandnumber_ != NULL) originalinvoicerevisiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicerevisiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceCorrectionDocumentInfo::originalinvoicerevisiondateandnumber() const {
  return originalinvoicerevisiondateandnumber_ != NULL ? *originalinvoicerevisiondateandnumber_ : *default_instance_->originalinvoicerevisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::mutable_originalinvoicerevisiondateandnumber() {
  set_has_originalinvoicerevisiondateandnumber();
  if (originalinvoicerevisiondateandnumber_ == NULL) originalinvoicerevisiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  return originalinvoicerevisiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::release_originalinvoicerevisiondateandnumber() {
  clear_has_originalinvoicerevisiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicerevisiondateandnumber_;
  originalinvoicerevisiondateandnumber_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber OriginalInvoiceCorrectionDateAndNumber = 8;
inline bool InvoiceCorrectionDocumentInfo::has_originalinvoicecorrectiondateandnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InvoiceCorrectionDocumentInfo::set_has_originalinvoicecorrectiondateandnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InvoiceCorrectionDocumentInfo::clear_has_originalinvoicecorrectiondateandnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InvoiceCorrectionDocumentInfo::clear_originalinvoicecorrectiondateandnumber() {
  if (originalinvoicecorrectiondateandnumber_ != NULL) originalinvoicecorrectiondateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_originalinvoicecorrectiondateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& InvoiceCorrectionDocumentInfo::originalinvoicecorrectiondateandnumber() const {
  return originalinvoicecorrectiondateandnumber_ != NULL ? *originalinvoicecorrectiondateandnumber_ : *default_instance_->originalinvoicecorrectiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::mutable_originalinvoicecorrectiondateandnumber() {
  set_has_originalinvoicecorrectiondateandnumber();
  if (originalinvoicecorrectiondateandnumber_ == NULL) originalinvoicecorrectiondateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  return originalinvoicecorrectiondateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* InvoiceCorrectionDocumentInfo::release_originalinvoicecorrectiondateandnumber() {
  clear_has_originalinvoicecorrectiondateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = originalinvoicecorrectiondateandnumber_;
  originalinvoicecorrectiondateandnumber_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PriceListDocumentInfo

// optional string PriceListEffectiveDate = 1;
inline bool PriceListDocumentInfo::has_pricelisteffectivedate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceListDocumentInfo::set_has_pricelisteffectivedate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceListDocumentInfo::clear_has_pricelisteffectivedate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceListDocumentInfo::clear_pricelisteffectivedate() {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_->clear();
  }
  clear_has_pricelisteffectivedate();
}
inline const ::std::string& PriceListDocumentInfo::pricelisteffectivedate() const {
  return *pricelisteffectivedate_;
}
inline void PriceListDocumentInfo::set_pricelisteffectivedate(const ::std::string& value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
}
inline void PriceListDocumentInfo::set_pricelisteffectivedate(const char* value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
}
inline void PriceListDocumentInfo::set_pricelisteffectivedate(const char* value, size_t size) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListDocumentInfo::mutable_pricelisteffectivedate() {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  return pricelisteffectivedate_;
}
inline ::std::string* PriceListDocumentInfo::release_pricelisteffectivedate() {
  clear_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pricelisteffectivedate_;
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Docflow.DocumentDateAndNumber ContractDocumentDateAndNumber = 2;
inline bool PriceListDocumentInfo::has_contractdocumentdateandnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceListDocumentInfo::set_has_contractdocumentdateandnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceListDocumentInfo::clear_has_contractdocumentdateandnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceListDocumentInfo::clear_contractdocumentdateandnumber() {
  if (contractdocumentdateandnumber_ != NULL) contractdocumentdateandnumber_->::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber::Clear();
  clear_has_contractdocumentdateandnumber();
}
inline const ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber& PriceListDocumentInfo::contractdocumentdateandnumber() const {
  return contractdocumentdateandnumber_ != NULL ? *contractdocumentdateandnumber_ : *default_instance_->contractdocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* PriceListDocumentInfo::mutable_contractdocumentdateandnumber() {
  set_has_contractdocumentdateandnumber();
  if (contractdocumentdateandnumber_ == NULL) contractdocumentdateandnumber_ = new ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber;
  return contractdocumentdateandnumber_;
}
inline ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* PriceListDocumentInfo::release_contractdocumentdateandnumber() {
  clear_has_contractdocumentdateandnumber();
  ::Diadoc::Api::Proto::Docflow::DocumentDateAndNumber* temp = contractdocumentdateandnumber_;
  contractdocumentdateandnumber_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ContractDocumentInfo

// optional string ContractPrice = 1;
inline bool ContractDocumentInfo::has_contractprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContractDocumentInfo::set_has_contractprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContractDocumentInfo::clear_has_contractprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContractDocumentInfo::clear_contractprice() {
  if (contractprice_ != &::google::protobuf::internal::kEmptyString) {
    contractprice_->clear();
  }
  clear_has_contractprice();
}
inline const ::std::string& ContractDocumentInfo::contractprice() const {
  return *contractprice_;
}
inline void ContractDocumentInfo::set_contractprice(const ::std::string& value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
}
inline void ContractDocumentInfo::set_contractprice(const char* value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
}
inline void ContractDocumentInfo::set_contractprice(const char* value, size_t size) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractDocumentInfo::mutable_contractprice() {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  return contractprice_;
}
inline ::std::string* ContractDocumentInfo::release_contractprice() {
  clear_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractprice_;
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ContractType = 2;
inline bool ContractDocumentInfo::has_contracttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContractDocumentInfo::set_has_contracttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContractDocumentInfo::clear_has_contracttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContractDocumentInfo::clear_contracttype() {
  if (contracttype_ != &::google::protobuf::internal::kEmptyString) {
    contracttype_->clear();
  }
  clear_has_contracttype();
}
inline const ::std::string& ContractDocumentInfo::contracttype() const {
  return *contracttype_;
}
inline void ContractDocumentInfo::set_contracttype(const ::std::string& value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void ContractDocumentInfo::set_contracttype(const char* value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void ContractDocumentInfo::set_contracttype(const char* value, size_t size) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractDocumentInfo::mutable_contracttype() {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  return contracttype_;
}
inline ::std::string* ContractDocumentInfo::release_contracttype() {
  clear_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contracttype_;
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SupplementaryAgreementDocumentInfo

// optional string Total = 1;
inline bool SupplementaryAgreementDocumentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SupplementaryAgreementDocumentInfo::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& SupplementaryAgreementDocumentInfo::total() const {
  return *total_;
}
inline void SupplementaryAgreementDocumentInfo::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SupplementaryAgreementDocumentInfo::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* SupplementaryAgreementDocumentInfo::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ContractType = 2;
inline bool SupplementaryAgreementDocumentInfo::has_contracttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_contracttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_contracttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SupplementaryAgreementDocumentInfo::clear_contracttype() {
  if (contracttype_ != &::google::protobuf::internal::kEmptyString) {
    contracttype_->clear();
  }
  clear_has_contracttype();
}
inline const ::std::string& SupplementaryAgreementDocumentInfo::contracttype() const {
  return *contracttype_;
}
inline void SupplementaryAgreementDocumentInfo::set_contracttype(const ::std::string& value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_contracttype(const char* value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_contracttype(const char* value, size_t size) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SupplementaryAgreementDocumentInfo::mutable_contracttype() {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  return contracttype_;
}
inline ::std::string* SupplementaryAgreementDocumentInfo::release_contracttype() {
  clear_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contracttype_;
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ContractNumber = 3;
inline bool SupplementaryAgreementDocumentInfo::has_contractnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_contractnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_contractnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SupplementaryAgreementDocumentInfo::clear_contractnumber() {
  if (contractnumber_ != &::google::protobuf::internal::kEmptyString) {
    contractnumber_->clear();
  }
  clear_has_contractnumber();
}
inline const ::std::string& SupplementaryAgreementDocumentInfo::contractnumber() const {
  return *contractnumber_;
}
inline void SupplementaryAgreementDocumentInfo::set_contractnumber(const ::std::string& value) {
  set_has_contractnumber();
  if (contractnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractnumber_ = new ::std::string;
  }
  contractnumber_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_contractnumber(const char* value) {
  set_has_contractnumber();
  if (contractnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractnumber_ = new ::std::string;
  }
  contractnumber_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_contractnumber(const char* value, size_t size) {
  set_has_contractnumber();
  if (contractnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractnumber_ = new ::std::string;
  }
  contractnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SupplementaryAgreementDocumentInfo::mutable_contractnumber() {
  set_has_contractnumber();
  if (contractnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractnumber_ = new ::std::string;
  }
  return contractnumber_;
}
inline ::std::string* SupplementaryAgreementDocumentInfo::release_contractnumber() {
  clear_has_contractnumber();
  if (contractnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractnumber_;
    contractnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ContractDate = 4;
inline bool SupplementaryAgreementDocumentInfo::has_contractdate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SupplementaryAgreementDocumentInfo::set_has_contractdate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SupplementaryAgreementDocumentInfo::clear_has_contractdate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SupplementaryAgreementDocumentInfo::clear_contractdate() {
  if (contractdate_ != &::google::protobuf::internal::kEmptyString) {
    contractdate_->clear();
  }
  clear_has_contractdate();
}
inline const ::std::string& SupplementaryAgreementDocumentInfo::contractdate() const {
  return *contractdate_;
}
inline void SupplementaryAgreementDocumentInfo::set_contractdate(const ::std::string& value) {
  set_has_contractdate();
  if (contractdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdate_ = new ::std::string;
  }
  contractdate_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_contractdate(const char* value) {
  set_has_contractdate();
  if (contractdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdate_ = new ::std::string;
  }
  contractdate_->assign(value);
}
inline void SupplementaryAgreementDocumentInfo::set_contractdate(const char* value, size_t size) {
  set_has_contractdate();
  if (contractdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdate_ = new ::std::string;
  }
  contractdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SupplementaryAgreementDocumentInfo::mutable_contractdate() {
  set_has_contractdate();
  if (contractdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdate_ = new ::std::string;
  }
  return contractdate_;
}
inline ::std::string* SupplementaryAgreementDocumentInfo::release_contractdate() {
  clear_has_contractdate();
  if (contractdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractdate_;
    contractdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Docflow
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Docflow_2fDocumentInfo_2eproto__INCLUDED
